// File: OllamaDocumentationGenerator.ajs

const { OllamaClient, Message, GenerateOptions, ROLES } = require('./lib/ollamaClient');
const modelTraversal = require('./lib/modelTraversal');

console.clear();
console.show();

const ollama = new OllamaClient();
const MODEL = 'llama3.1'; // Adjust this to the model you want to use

async function generateViewDocumentation(view) {
    console.log(`Generating documentation for view: ${view.name}`);

    const systemContext = createSystemContext(view);
    const viewDocumentation = await generateDocumentation(
        systemContext, 
        "Analyze the view and provide a concise technical summary. Focus on its purpose, key components, and significant relationships."
    );
    console.log("View documentation generated.");

    const updates = await generateElementDocumentation(view, systemContext, viewDocumentation);
    console.log("Documentation generation complete.");

    return updates;
}

function createSystemContext(view) {
    let context = `View Name: ${view.name}\n`;
    context += `View Documentation: ${view.documentation || 'None'}\n\n`;
    context += "Elements and Relationships:\n";

    modelTraversal.traverse({
        viewElementHandler: (element) => {
            context += `- Element: ${element.name} (${element.type})\n`;
            context += `  Documentation: ${element.documentation || 'None'}\n`;
            if (element.prop()) {
                context += `  Properties: ${JSON.stringify(element.prop())}\n`;
            }
        },
        viewRelationshipHandler: (relationship) => {
            context += `- Relationship: ${relationship.name || 'Unnamed'} (${relationship.type})\n`;
            context += `  Source: ${relationship.source.name}, Target: ${relationship.target.name}\n`;
            context += `  Documentation: ${relationship.documentation || 'None'}\n`;
            if (relationship.prop()) {
                context += `  Properties: ${JSON.stringify(relationship.prop())}\n`;
            }
        }
    }, view);
    return context;
}

async function generateDocumentation(context, prompt) {
    const messages = [
        new Message(ROLES.SYSTEM, "You are a technical documentation assistant for enterprise architecture. Provide concise, factual information in a professional tone. Focus on accuracy, relevance, and technical insights."),
        new Message(ROLES.SYSTEM, context),
        new Message(ROLES.USER, prompt)
    ];

    const options = new GenerateOptions({
        temperature: 0.2,
        topK: 40,
        topP: 0.9,
        stream: false
    });

    const response = await ollama.generateChatCompletion(MODEL, messages, options);
    const tokensPerSecond = calculateTokensPerSecond(response);
    console.log(`Generation stats: ${tokensPerSecond.toFixed(2)} tokens/s`);
    return response.message.content.trim();
}

async function generateProperties(context, prompt) {
    const messages = [
        new Message(ROLES.SYSTEM, "You are a technical metadata generator for enterprise architecture elements. Provide concise, relevant properties as JSON."),
        new Message(ROLES.SYSTEM, context),
        new Message(ROLES.USER, prompt)
    ];

    const options = new GenerateOptions({
        temperature: 0.2,
        topK: 40,
        topP: 0.9,
        stream: false,
        format: 'json'
    });

    const response = await ollama.generateChatCompletion(MODEL, messages, options);
    const tokensPerSecond = calculateTokensPerSecond(response);
    console.log(`Properties generation stats: ${tokensPerSecond.toFixed(2)} tokens/s`);
    return safeJSONParse(response.message.content);
}

function safeJSONParse(str) {
    try {
        // First, try parsing the string as-is
        return JSON.parse(str);
    } catch (e) {
        console.log("Initial JSON parsing failed. Attempting to clean and parse...");
        
        // Remove any text before the first '{' and after the last '}'
        let cleaned = str.substring(str.indexOf('{'), str.lastIndexOf('}') + 1);
        
        // Replace any single quotes with double quotes
        cleaned = cleaned.replace(/'/g, '"');
        
        // Attempt to parse again
        try {
            return JSON.parse(cleaned);
        } catch (e) {
            console.log("Cleaned JSON parsing failed. Attempting to fix common issues...");
            
            // Fix common JSON issues
            cleaned = cleaned
                // Ensure property names are double-quoted
                .replace(/(\w+)(?=\s*:)/g, '"$1"')
                // Remove trailing commas
                .replace(/,\s*([\]}])/g, '$1');
            
            try {
                return JSON.parse(cleaned);
            } catch (e) {
                console.error("All JSON parsing attempts failed. Returning an empty object.");
                return {};
            }
        }
    }
}
function calculateTokensPerSecond(response) {
    const evalCount = response.eval_count;
    const evalDurationNs = response.eval_duration;
    const evalDurationSeconds = evalDurationNs / 1e9;
    return evalCount / evalDurationSeconds;
}

async function generateElementDocumentation(view, systemContext, viewDocumentation) {
    const updates = {
        view: { id: view.id, documentation: viewDocumentation },
        elements: [],
        relationships: []
    };

    const items = [];
    modelTraversal.traverse({
        viewElementHandler: (element) => {
            items.push({ type: 'element', item: element });
        },
        viewRelationshipHandler: (relationship) => {
            items.push({ type: 'relationship', item: relationship });
        }
    }, view);

    const totalItems = items.length;
    console.log(`Total items to process: ${totalItems}`);

    for (let i = 0; i < items.length; i++) {
        const { type, item } = items[i];
        const itemName = type === 'element' ? item.name : (item.name || `${item.source.name} -> ${item.target.name}`);
        console.log(`Processing ${type}: ${itemName} (${i + 1}/${totalItems})`);

        const docPrompt = `Analyze the ${type} '${itemName}' (${item.type}) within the context of the view. 
                           Provide a concise technical description focusing on its role, significance, and key characteristics.`;

        const documentation = await generateDocumentation(systemContext + "\n" + viewDocumentation, docPrompt);

        if (type === 'element') {
            const propPrompt = `
Analyze the element '${itemName}' (${type}) in the context of the current view. Generate 3-5 relevant properties as simple name-value pairs. Each property should have a concise name and a short string or numerical value. Focus on technical or business attributes that provide valuable metadata for enterprise architecture. 

Format your response strictly as a JSON object with property names as keys and their values as strings or numbers. For example:

{
  "Cost": "USD 1000",
  "Priority": "High",
  "Implementation Time": "6 months",
  "Data Sensitivity": "Confidential",
  "Scalability": 8
}

Ensure all property names are clear and self-explanatory. Avoid complex or nested structures.`
            
            const properties = await generateProperties(systemContext + "\n" + viewDocumentation, propPrompt);

            updates.elements.push({ 
                id: item.id, 
                documentation: documentation,
                properties: properties
            });
        } else {
            updates.relationships.push({ 
                id: item.id, 
                documentation: documentation 
            });
        }
    }

    return updates;
}

// Main execution
const selectedView = $(selection).filter("archimate-diagram-model").first();

if (selectedView) {
    generateViewDocumentation(selectedView)
        .then(updates => {
            console.log("Generated documentation updates:");
            console.log(JSON.stringify(updates, null, 2));
        })
        .catch(error => console.error("Error:", error));
} else {
    console.error("No view selected. Please select a view and run the script again.");
}