// File: Documentation Augmenter.ajs

const { OllamaClient, Message, GenerateOptions, ROLES } = require('./lib/ollamaClient');
const modelTraversal = require('./lib/modelTraversal');

console.clear();
console.show();

const ollama = new OllamaClient();
const MODEL = 'llama3.1'; // Adjust this to the model you want to use

// Flag to control relationship documentation generation
const GENERATE_RELATIONSHIP_DOCS = false; // Set to true if you want to generate relationship documentation

async function generateViewDocumentation(view) {
    console.log(`Generating documentation for view: ${view.name}`);

    const systemContext = createSystemContext(view);
    const viewDocumentation = await generateDocumentation(
        systemContext, 
        "Analyze the view and provide a concise technical summary. Focus on its purpose, key components, and significant relationships."
    );
    console.log("View documentation generated.");

    const updates = await generateElementDocumentation(view, systemContext, viewDocumentation);
    console.log("Documentation generation complete.");

    return updates;
}

function createSystemContext(view) {
    let context = `View Name: ${view.name}\n`;
    context += `View Documentation: ${view.documentation || 'None'}\n\n`;
    context += "Elements and Relationships:\n";

    modelTraversal.traverse({
        viewElementHandler: (element) => {
            context += `- Element: ${element.name} (${element.type})\n`;
            context += `  Documentation: ${element.documentation || 'None'}\n`;
        },
        viewRelationshipHandler: (relationship) => {
            context += `- Relationship: ${relationship.name || 'Unnamed'} (${relationship.type})\n`;
            context += `  Source: ${relationship.source.name}, Target: ${relationship.target.name}\n`;
            context += `  Documentation: ${relationship.documentation || 'None'}\n`;
        }
    }, view);
    return context;
}

async function generateDocumentation(context, prompt) {
    const messages = [
        new Message(ROLES.SYSTEM, "You are a technical documentation assistant for enterprise architecture. Provide concise, factual information in a professional tone. Focus on accuracy, relevance, and technical insights."),
        new Message(ROLES.SYSTEM, context),
        new Message(ROLES.USER, prompt)
    ];

    const options = new GenerateOptions({
        temperature: 0.2,
        topK: 40,
        topP: 0.9,
        stream: false
    });

    const response = await ollama.generateChatCompletion(MODEL, messages, options);
    let documentation = response.message.content.trim();
    
    // Ensure paragraph breaks are preserved by using double newlines
    documentation = documentation.replace(/\n/g, '\n\n');
    
    return documentation;
}

async function generateElementDocumentation(view, systemContext, viewDocumentation) {
    const updates = {
        view: { id: view.id, documentation: viewDocumentation },
        elements: [],
        relationships: []
    };

    const items = [];
    modelTraversal.traverse({
        viewElementHandler: (element) => {
            items.push({ type: 'element', item: element });
        },
        viewRelationshipHandler: (relationship) => {
            if (GENERATE_RELATIONSHIP_DOCS) {
                items.push({ type: 'relationship', item: relationship });
            }
        }
    }, view);

    const totalItems = items.length;
    console.log(`Total items to process: ${totalItems}`);

    for (let i = 0; i < items.length; i++) {
        const { type, item } = items[i];
        const itemName = type === 'element' ? item.name : (item.name || `${item.source.name} -> ${item.target.name}`);
        console.log(`Processing ${type}: ${itemName} (${i + 1}/${totalItems})`);

        const docPrompt = `Analyze the ${type} '${itemName}' (${item.type}) within the context of the view. 
                           Provide a concise technical description focusing on its role, significance, and key characteristics.`;

        const documentation = await generateDocumentation(systemContext + "\n" + viewDocumentation, docPrompt);

        if (type === 'element') {
            updates.elements.push({ 
                id: item.id, 
                updates: {
                    documentation: documentation
                }
            });
        } else {
            updates.relationships.push({ 
                id: item.id, 
                updates: { documentation: documentation }
            });
        }
    }

    return updates;
}

function formatDocumentation(text) {
    // Replace multiple newlines with a single newline
    return text.replace(/\n+/g, '\n').trim();
}

function applyUpdates(updates) {
    console.log("Applying updates...");
    
    // Update view
    if (updates.view && updates.view.id) {
        let view = $('#' + updates.view.id);
        if (view.size() > 0) {
            if (updates.view.documentation) {
                view.first().documentation = formatDocumentation(updates.view.documentation);
            }
            console.log("View updated: " + view.first().name);
        } else {
            console.error("View not found: " + updates.view.id);
        }
    }
    
    // Update elements
    if (updates.elements && Array.isArray(updates.elements)) {
        updates.elements.forEach(elementUpdate => {
            let element = $('#' + elementUpdate.id);
            if (element.size() > 0) {
                if (elementUpdate.updates.documentation) {
                    element.first().documentation = formatDocumentation(elementUpdate.updates.documentation);
                }
                console.log("Element updated: " + element.first().name);
            } else {
                console.error("Element not found: " + elementUpdate.id);
            }
        });
    }
    
    // Update relationships
    if (GENERATE_RELATIONSHIP_DOCS && updates.relationships && Array.isArray(updates.relationships)) {
        updates.relationships.forEach(relationshipUpdate => {
            let relationship = $('#' + relationshipUpdate.id);
            if (relationship.size() > 0) {
                if (relationshipUpdate.updates.documentation) {
                    relationship.first().documentation = formatDocumentation(relationshipUpdate.updates.documentation);
                }
                console.log("Relationship updated: " + (relationship.first().name || "Unnamed relationship"));
            } else {
                console.error("Relationship not found: " + relationshipUpdate.id);
            }
        });
    }
    
    console.log("Updates applied successfully.");
}

async function generateAndApplyDocumentation(view) {
    try {
        console.log(`Generating and applying documentation for view: ${view.name}`);
        
        const updates = await generateViewDocumentation(view);
        
        console.log("Generated documentation updates:");
       
        applyUpdates(updates);
        
        console.log("Documentation generation and application complete.");
    } catch (error) {
        console.error("Error: " + error.toString());
    }
}

// Main execution
const selectedView = $(selection).filter("archimate-diagram-model").first();

if (selectedView) {
    generateAndApplyDocumentation(selectedView);
} else {
    console.error("No view selected. Please select a view and run the script again.");
}