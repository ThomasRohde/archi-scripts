/**
 * @name Generate Capability Model
 * @description This script generates an ArchiMate capability model using the Anthropic API, iteratively refining the model.
 * @version 1.1
 * @author Claude AI Assistant
 * @lastModifiedDate 2024-08-13
 */

console.clear();
console.show();

const { LLMClient, LLMMessage, LLMGenerateOptions, ROLES } = require('./lib/llm');
const layoutDagre = require('./lib/layoutDagre');
const modelManipulation = require('./lib/modelManipulation');

// Initialize logger
const jarchiLogger = require('./lib/jarchiLogger');
const log = jarchiLogger.createLogger('GenerateCapabilityModel', __DIR__);

// Initialize LLM client
const llmClient = new LLMClient('anthropic');
// const llmClient = new LLMClient('ollama');

// Constants
const ITERATIONS = 3;
const MODEL = 'claude-3-haiku-20240307';
// const MODEL = 'llama3.1';

// Function to get user input
function getUserInput(prompt) {
    return window.prompt(prompt);
}

// Function to generate capability model using LLM
async function generateCapabilityModel(userDescription, previousModel = null, iteration = 1) {
    let prompt = `You are an AI assistant tasked with creating an ArchiMate capability model based on a user's description. Your goal is to analyze the description and generate a JSON object that represents the capability model using only ArchiMate Strategy Capability elements.

Here is the user's description of the organization:
<user_description>
${userDescription}
</user_description>

This is iteration ${iteration} of ${ITERATIONS}. `;

    if (iteration === 1) {
        prompt += "Create an initial high-level capability model.";
    } else {
        prompt += `Expand and refine the previous model. For each capability in the previous model, provide more detailed sub-capabilities.

Previous model:
<previous_model>
${JSON.stringify(previousModel, null, 2)}
</previous_model>`;
    }

    prompt += `

Create a JSON object to represent the ArchiMate capability model. The structure should be:

<json_structure>
{
    "nodes": [
        {
            "id": "<unique id>",
            "type": "capability",
            "name": "<name of capability>",
            "description": "<description of capability>",
        },
        ... more capabilities ...
    ],
    "relationships": [
        {
            "source": "<id of source capability>",
            "target": "<id of target capability>",
            "type": "composition-relationship"
        },
        ... more relationships ...
    ]
}
</json_structure>

Guidelines:
1. Use only "capability" as the type for all nodes.
2. Create a hierarchical structure with high-level capabilities and sub-capabilities.
3. Use only "composition-relationship" relationships to represent the hierarchy.
4. Provide clear and concise names and descriptions for each capability.
5. Ensure each capability has a unique ID (e.g., "cap1", "cap2", etc.).
6. If refining a previous model, maintain the existing structure and add more detailed sub-capabilities.

After analyzing the description and creating the model, format your response as a valid JSON object representing the capability model. Enclose the entire JSON object within <capability_model> tags.`;

    const messages = [new LLMMessage(ROLES.USER, prompt)];

    const options = new LLMGenerateOptions({
        model: MODEL,
        maxTokens: 4096,
        temperature: 0.7
    });

    try {
        const response = await llmClient.generateChatCompletion(messages, options);
        const content = response.content;
        
        log.markdown(content.replace(/<capability_model>[\s\S]*?<\/capability_model>/, ''));

        const jsonMatch = content.match(/<capability_model>([\s\S]*?)<\/capability_model>/);
        if (jsonMatch) {
            const jsonObject = JSON.parse(jsonMatch[1]);
            log.code(jsonObject);
            return jsonObject;
        } else {
            throw new Error("JSON structure not found in the response");
        }
    } catch (error) {
        log.error('Error generating capability model', { error: error.toString() });
        throw error;
    }
}

// Main execution
(async function() {
    try {
        const userDescription = getUserInput("Describe the organization for which you want to create a capability model:");
        if (userDescription) {
            log.info('Generating capability model');
            let view = $(selection).filter("archimate-diagram-model").first();
            if (!view) {
                view = model.createArchimateView("Generated Capability Model");
            }

            let previousModel = null;

            for (let i = 1; i <= ITERATIONS; i++) {
                log.info(`Iteration ${i} of ${ITERATIONS}`);
                const modelJson = await generateCapabilityModel(userDescription, previousModel, i);
                
                // Use updateModel for all iterations
                const updates = modelManipulation.updateModel(modelJson);
                log.info(`Model updated (iteration ${i})`);
                log.debug('Model updates', updates);
                
                // Update previousModel for the next iteration
                previousModel = modelManipulation.createModelJson();
            }

            // Apply custom layout
            customCapabilityLayout(view);

            log.info('Capability model generation and layout complete');
        } else {
            log.warn('User cancelled or provided no description');
        }
    } catch (error) {
        log.error('Error in main execution', { error: error.toString() });
    }
})();

function customCapabilityLayout(view) {
    const rootCapabilities = $("element").filter(e => {
        if (e.type !== "capability") return false;
        const incomingCompositions = $(e).inRels().filter(r => r.type === "composition-relationship");
        return incomingCompositions.size() === 0;
    });

    const horizontalSpacing = 30;
    const verticalSpacing = 20;
    let x = 10;

    const colorPalette = [
        "#E6F3FF", // Light Blue
        "#FFF0E6", // Light Peach
        "#E6FFE6", // Light Green
        "#F2E6FF", // Light Purple
        "#FFFFE6"  // Light Yellow
    ];

    // If there's only one root capability, use its children as the top-level capabilities
    if (rootCapabilities.size() === 1) {
        const singleRoot = rootCapabilities.first();
        const topLevelCapabilities = getCapabilityChildren(singleRoot);
        layoutTopLevelCapabilities(view, topLevelCapabilities, x, 10, horizontalSpacing, colorPalette);
    } else {
        layoutTopLevelCapabilities(view, rootCapabilities, x, 10, horizontalSpacing, colorPalette);
    }
}

function layoutTopLevelCapabilities(view, capabilities, startX, startY, horizontalSpacing, colorPalette) {
    let x = startX;
    capabilities.each((capability, index) => {
        const children = getCapabilityChildren(capability);
        const [width, height] = calculateCapabilitySize(capability, children);

        const capabilityInView = view.add(capability, x, startY, width, height);
        capabilityInView.textPosition = 0;
        capabilityInView.showIcon = 2;
        capabilityInView.fillColor = colorPalette[0];

        let childY = startY + 40;
        layoutChildren(view, capabilityInView, children, x + 10, childY, width - 20, 1, colorPalette);

        x += width + horizontalSpacing;
    });
}

function getCapabilityChildren(capability) {
    return $("element").filter(e => {
        if (e.type !== "capability") return false;
        const incomingCompositions = $(e).inRels().filter(r => r.type === "composition-relationship" && r.source.id === capability.id);
        return incomingCompositions.size() > 0;
    });
}

function calculateCapabilitySize(capability, children) {
    const minWidth = 120;
    const minHeight = 30;
    const padding = 20;
    const bottomPadding = 20; // New constant for bottom padding

    if (children.size() === 0) {
        return [Math.max(minWidth, capability.name.length * 8), minHeight];
    }

    let maxChildWidth = 0;
    let totalChildHeight = 0;

    children.each(child => {
        const [childWidth, childHeight] = calculateCapabilitySize(child, getCapabilityChildren(child));
        maxChildWidth = Math.max(maxChildWidth, childWidth);
        totalChildHeight += childHeight + 10;
    });

    const width = Math.max(minWidth, maxChildWidth + padding, capability.name.length * 8);
    const height = Math.max(minHeight, totalChildHeight + padding + bottomPadding); // Added bottomPadding

    return [width, height];
}

function layoutChildren(view, parentInView, children, startX, startY, maxWidth, level, colorPalette) {
    let y = startY;
    const bottomPadding = 20;
    let hasNonLeafChildren = false;

    children.each(child => {
        const grandchildren = getCapabilityChildren(child);
        const [width, height] = calculateCapabilitySize(child, grandchildren);

        const childInView = view.add(child, startX, y, width, height);
        childInView.textPosition = 1;
        childInView.showIcon = 2;

        if (grandchildren.size() === 0) {
            childInView.fillColor = "#F0F0F0"; // Light grey for leaf nodes
        } else {
            hasNonLeafChildren = true;
            childInView.textPosition = 0;
            childInView.fillColor = colorPalette[level % colorPalette.length];
            layoutChildren(view, childInView, grandchildren, startX + 10, y + 30, width - 20, level + 1, colorPalette);
        }

        y += height + 10;
    });

    // Adjust parent height to include bottom padding only if it has non-leaf children
    if (hasNonLeafChildren) {
        const parentBounds = parentInView.bounds;
        parentInView.bounds = {
            x: parentBounds.x,
            y: parentBounds.y,
            width: parentBounds.width,
            height: parentBounds.height + bottomPadding
        };
    }
}