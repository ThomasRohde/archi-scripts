/**
 * @name Generate Capability Model
 * @description This script generates an ArchiMate capability model using the Anthropic API, iteratively refining the model.
 * @version 1.1
 * @author Claude AI Assistant
 * @lastModifiedDate 2024-08-13
 */

console.clear();
console.show();

const { LLMClient, LLMMessage, LLMGenerateOptions, ROLES } = require('./lib/llm');
const layoutDagre = require('./lib/layoutDagre');
const modelManipulation = require('./lib/modelManipulation');

// Initialize logger
const jarchiLogger = require('./lib/jarchiLogger');
const log = jarchiLogger.createLogger('GenerateCapabilityModel', __DIR__);

// Initialize LLM client
const llmClient = new LLMClient('anthropic');
// const llmClient = new LLMClient('ollama');

// Constants
const ITERATIONS = 6;
const MODEL = 'claude-3-haiku-20240307';
// const MODEL = 'llama3.1';

// Function to get user input
function getUserInput(prompt) {
    return window.prompt(prompt);
}

// Function to generate capability model using LLM
async function generateCapabilityModel(userDescription, previousModel = null, iteration = 1) {
    let prompt = `You are an AI assistant tasked with expanding an ArchiMate capability model. Your goal is to analyze the existing model and suggest new capabilities to add, ensuring a balanced and hierarchical structure.

    Here is the user's description of the organization:
    <user_description>
    ${userDescription}
    </user_description>
    
    This is iteration ${iteration} of ${ITERATIONS}. 
    
    Previous model:
    <previous_model>
    ${JSON.stringify(previousModel, null, 2)}
    </previous_model>
    
    For this iteration, follow these guidelines:
    
    1. Iteration 1: Create a broad set of top-level capabilities that cover the main areas of the organization. Each of these should have 2-3 immediate sub-capabilities.
    
    2. Iteration 2: Focus on expanding the breadth of the model. Add more sub-capabilities to each top-level capability, ensuring a balanced structure.
    
    3. Iteration 3 and beyond: Deepen the model by adding more specific sub-capabilities to the existing structure.
    
    IMPORTANT: Every new capability MUST have a parent from the existing model. Do not create orphaned capabilities.
    
    Please suggest new capabilities to add to this model. Your response should be a JSON object with the following structure:
    
    <json_structure>
    {
        "new_capabilities": [
            {
                "id": "<unique id>",
                "type": "capability",
                "name": "<name of capability>",
                "description": "<description of capability>",
                "parent": "<id of parent capability>"
            },
            ... more new capabilities ...
        ]
    }
    </json_structure>
    
    Guidelines:
    1. Only suggest new capabilities to add to the existing model.
    2. EVERY new capability MUST have a parent from the existing model.
    3. Provide clear and concise names and descriptions for each new capability.
    4. Ensure each new capability has a unique ID (e.g., "cap1", "cap2", etc.).
    5. Focus on creating a balanced hierarchy, with a good mix of breadth and depth.
    6. Avoid creating duplicate capabilities or those with very similar names/functions.
    
    After analyzing the existing model and suggesting new capabilities, format your response as a valid JSON object. Enclose the entire JSON object within <capability_model_update> tags.`;

    const messages = [new LLMMessage(ROLES.USER, prompt)];

    const options = new LLMGenerateOptions({
        model: MODEL,
        maxTokens: 4096,
        temperature: 0.7
    });

    try {
        const response = await llmClient.generateChatCompletion(messages, options);
        const content = response.content;
        
        log.markdown(content.replace(/<capability_model_update>[\s\S]*?<\/capability_model_update>/, ''));

        const jsonMatch = content.match(/<capability_model_update>([\s\S]*?)<\/capability_model_update>/);
        if (jsonMatch) {
            const jsonObject = JSON.parse(jsonMatch[1]);
            log.code(jsonObject);
            return jsonObject;
        } else {
            throw new Error("JSON structure not found in the response");
        }
    } catch (error) {
        log.error('Error generating capability model', { error: error.toString() });
        throw error;
    }
}

function integrateUpdates(fullModel, updates) {
    if (!fullModel) {
        fullModel = { nodes: [], relationships: [] };
    }

    updates.new_capabilities.forEach(newCap => {
        fullModel.nodes.push(newCap);
        if (newCap.parent) {
            fullModel.relationships.push({
                source: newCap.parent,
                target: newCap.id,
                type: "composition-relationship"
            });
        }
    });

    return fullModel;
}

// Main execution
(async function() {
    try {
        const userDescription = getUserInput("Describe the organization for which you want to create a capability model:");
        if (userDescription) {
            log.info('Generating capability model');
            let view = $(selection).filter("archimate-diagram-model").first();
            if (!view) {
                view = model.createArchimateView("Generated Capability Model");
            }

            let fullModel = null;

            for (let i = 1; i <= ITERATIONS; i++) {
                log.info(`Iteration ${i} of ${ITERATIONS}`);
                const modelUpdates = await generateCapabilityModel(userDescription, fullModel, i);
                
                // Integrate updates into the full model
                fullModel = integrateUpdates(fullModel, modelUpdates);
                
                // Update the model in Archi
                const updates = modelManipulation.updateModel(fullModel);
                log.info(`Model updated (iteration ${i})`);
                log.debug('Model updates', updates);
            }

            // Apply custom layout
            customCapabilityLayout(view);

            log.info('Capability model generation and layout complete');
        } else {
            log.warn('User cancelled or provided no description');
        }
    } catch (error) {
        log.error('Error in main execution', { error: error.toString() });
    }
})();

function customCapabilityLayout(view) {
    const rootCapabilities = $("element").filter(e => {
        if (e.type !== "capability") return false;
        const incomingCompositions = $(e).inRels().filter(r => r.type === "composition-relationship");
        return incomingCompositions.size() === 0;
    });

    const horizontalSpacing = 30;
    const verticalSpacing = 20;
    let x = 10;

    const colorPalette = [
        "#E6F3FF", // Light Blue
        "#FFF0E6", // Light Peach
        "#E6FFE6", // Light Green
        "#F2E6FF", // Light Purple
        "#FFFFE6"  // Light Yellow
    ];

    // Calculate max widths for each level
    const levelWidths = calculateLevelWidths(rootCapabilities);

    // If there's only one root capability, use its children as the top-level capabilities
    if (rootCapabilities.size() === 1) {
        const singleRoot = rootCapabilities.first();
        const topLevelCapabilities = getCapabilityChildren(singleRoot);
        layoutTopLevelCapabilities(view, topLevelCapabilities, x, 10, horizontalSpacing, colorPalette, levelWidths);
    } else {
        layoutTopLevelCapabilities(view, rootCapabilities, x, 10, horizontalSpacing, colorPalette, levelWidths);
    }
}

function calculateLevelWidths(rootCapabilities) {
    const levelWidths = new Map();

    function traverse(capability, level = 0) {
        const children = getCapabilityChildren(capability);
        const [width, _] = calculateCapabilitySize(capability, children);
        
        levelWidths.set(level, Math.max(levelWidths.get(level) || 0, width));

        children.each(child => traverse(child, level + 1));
    }

    rootCapabilities.each(root => traverse(root));
    return levelWidths;
}

function layoutTopLevelCapabilities(view, capabilities, startX, startY, horizontalSpacing, colorPalette, levelWidths) {
    let x = startX;
    capabilities.each((capability, index) => {
        const children = getCapabilityChildren(capability);
        const [_, height] = calculateCapabilitySize(capability, children);
        const width = levelWidths.get(0);

        const capabilityInView = view.add(capability, x, startY, width, height);
        capabilityInView.textPosition = 0;
        capabilityInView.showIcon = 2;
        capabilityInView.fillColor = colorPalette[0];

        // Call layoutChildren with capabilityInView as the parent
        layoutChildren(capabilityInView, children, 10, 40, width - 20, 1, colorPalette, levelWidths);

        x += width + horizontalSpacing;
    });
}

function layoutChildren(parentInView, children, startX, startY, maxWidth, level, colorPalette, levelWidths) {
    let y = startY;
    const bottomPadding = 20;
    let hasNonLeafChildren = false;

    children.each(child => {
        const grandchildren = getCapabilityChildren(child);
        const [_, height] = calculateCapabilitySize(child, grandchildren);
        const width = levelWidths.get(level);

        // Add child to parent visual reference object instead of the view
        const childInView = parentInView.add(child, startX, y, width, height);
        childInView.textPosition = 1;
        childInView.showIcon = 2;

        if (grandchildren.size() === 0) {
            childInView.fillColor = "#F0F0F0"; // Light grey for leaf nodes
        } else {
            hasNonLeafChildren = true;
            childInView.textPosition = 0;
            childInView.fillColor = colorPalette[level % colorPalette.length];
            // Pass childInView as the parent for the next level of recursion
            layoutChildren(childInView, grandchildren, 10, 30, width - 20, level + 1, colorPalette, levelWidths);
        }

        y += height + 10;
    });

    // Adjust parent height to include bottom padding only if it has non-leaf children
    if (hasNonLeafChildren) {
        const parentBounds = parentInView.bounds;
        parentInView.bounds = {
            x: parentBounds.x,
            y: parentBounds.y,
            width: parentBounds.width,
            height: parentBounds.height + bottomPadding
        };
    }
}

function getCapabilityChildren(capability) {
    return $("element").filter(e => {
        if (e.type !== "capability") return false;
        const incomingCompositions = $(e).inRels().filter(r => r.type === "composition-relationship" && r.source.id === capability.id);
        return incomingCompositions.size() > 0;
    });
}

function calculateCapabilitySize(capability, children) {
    const minWidth = 120;
    const minHeight = 30;
    const padding = 20;
    const bottomPadding = 20;

    if (children.size() === 0) {
        return [Math.max(minWidth, capability.name.length * 8), minHeight];
    }

    let maxChildWidth = 0;
    let totalChildHeight = 0;

    children.each(child => {
        const [childWidth, childHeight] = calculateCapabilitySize(child, getCapabilityChildren(child));
        maxChildWidth = Math.max(maxChildWidth, childWidth);
        totalChildHeight += childHeight + 10;
    });

    const width = Math.max(minWidth, maxChildWidth + padding, capability.name.length * 8);
    const height = Math.max(minHeight, totalChildHeight + padding + bottomPadding);

    return [width, height];
}