/**
 * @name Generate Capability Model
 * @description This script generates an ArchiMate capability model using the Anthropic API, iteratively refining the model.
 */

console.clear();
console.show();

const { LLMClient, LLMMessage, LLMGenerateOptions, ROLES } = require('./lib/llm');
const layoutDagre = require('./lib/layoutDagre');
const modelManipulation = require('./lib/modelManipulation');

// Initialize logger
const jarchiLogger = require('./lib/jarchiLogger');
const log = jarchiLogger.createLogger('GenerateCapabilityModel', __DIR__);

// Initialize LLM client
const llmClient = new LLMClient('anthropic');
// const llmClient = new LLMClient('ollama');

// Constants
const ITERATIONS = 3;
const MODEL = 'claude-3-haiku-20240307';
// const MODEL = 'llama3.1';

// Function to get user input
function getUserInput(prompt) {
    return window.prompt(prompt);
}

// Function to generate capability model using LLM
async function generateCapabilityModel(userDescription, previousModel = null, iteration = 1) {
    let prompt = `You are an AI assistant tasked with creating an ArchiMate capability model based on a user's description. Your goal is to analyze the description and generate a JSON object that represents the capability model using only ArchiMate Strategy Capability elements.

Here is the user's description of the organization:
<user_description>
${userDescription}
</user_description>

This is iteration ${iteration} of ${ITERATIONS}. `;

    if (iteration === 1) {
        prompt += "Create an initial high-level capability model.";
    } else {
        prompt += `Expand and refine the previous model. For each capability in the previous model, provide more detailed sub-capabilities.

Previous model:
<previous_model>
${JSON.stringify(previousModel, null, 2)}
</previous_model>`;
    }

    prompt += `

Create a JSON object to represent the ArchiMate capability model. The structure should be:

<json_structure>
{
    "nodes": [
        {
            "id": "<unique id>",
            "type": "capability",
            "name": "<name of capability>",
            "description": "<description of capability>",
        },
        ... more capabilities ...
    ],
    "relationships": [
        {
            "source": "<id of source capability>",
            "target": "<id of target capability>",
            "type": "composition-relationship"
        },
        ... more relationships ...
    ]
}
</json_structure>

Guidelines:
1. Use only "capability" as the type for all nodes.
2. Create a hierarchical structure with high-level capabilities and sub-capabilities.
3. Use only "composition-relationship" relationships to represent the hierarchy.
4. Provide clear and concise names and descriptions for each capability.
5. Ensure each capability has a unique ID (e.g., "cap1", "cap2", etc.).
6. If refining a previous model, maintain the existing structure and add more detailed sub-capabilities.

After analyzing the description and creating the model, format your response as a valid JSON object representing the capability model. Enclose the entire JSON object within <capability_model> tags.`;

    const messages = [new LLMMessage(ROLES.USER, prompt)];

    const options = new LLMGenerateOptions({
        model: MODEL,
        maxTokens: 4000,
        temperature: 0.7
    });

    try {
        const response = await llmClient.generateChatCompletion(messages, options);
        const content = response.content;
        
        log.markdown(content.replace(/<capability_model>[\s\S]*?<\/capability_model>/, ''));

        const jsonMatch = content.match(/<capability_model>([\s\S]*?)<\/capability_model>/);
        if (jsonMatch) {
            const jsonObject = JSON.parse(jsonMatch[1]);
            log.code(jsonObject);
            return jsonObject;
        } else {
            throw new Error("JSON structure not found in the response");
        }
    } catch (error) {
        log.error('Error generating capability model', { error: error.toString() });
        throw error;
    }
}

// Main execution
(async function() {
    try {
        const userDescription = getUserInput("Describe the organization for which you want to create a capability model:");
        if (userDescription) {
            log.info('Generating capability model');
            let view = $(selection).filter("archimate-diagram-model").first();
            if (!view) {
                view = model.createArchimateView("Generated Capability Model");
            }

            let previousModel = null;

            for (let i = 1; i <= ITERATIONS; i++) {
                log.info(`Iteration ${i} of ${ITERATIONS}`);
                const modelJson = await generateCapabilityModel(userDescription, previousModel, i);
                
                // Use updateModel for all iterations
                const updates = modelManipulation.updateModel(modelJson);
                log.info(`Model updated (iteration ${i})`);
                log.debug('Model updates', updates);
                
                // Update previousModel for the next iteration
                previousModel = modelManipulation.createModelJson();
            }

            // Apply custom layout
            customCapabilityLayout(view);

            log.info('Capability model generation and layout complete');
        } else {
            log.warn('User cancelled or provided no description');
        }
    } catch (error) {
        log.error('Error in main execution', { error: error.toString() });
    }
})();

function customCapabilityLayout(view) {
    const rootCapabilities = $("element").filter(e => {
        if (e.type !== "capability") return false;
        const incomingCompositions = $(e).inRels().filter(r => r.type === "composition-relationship");
        return incomingCompositions.size() === 0;
    });

    const horizontalSpacing = 50;
    const verticalSpacing = 30;
    let x = 20;

    rootCapabilities.each((rootCap, index) => {
        const children = getCapabilityChildren(rootCap);
        const [width, height] = calculateCapabilitySize(rootCap, children);

        const rootCapInView = view.add(rootCap, x, 20, width, height);
        rootCapInView.textPosition = 0; // Set text position to top
        rootCapInView.showIcon = 2;

        let childY = 60; // Start children below the parent's name
        layoutChildren(view, rootCapInView, children, x + 20, childY, width - 40);

        x += width + horizontalSpacing;
    });
}

function getCapabilityChildren(capability) {
    return $("element").filter(e => {
        if (e.type !== "capability") return false;
        const incomingCompositions = $(e).inRels().filter(r => r.type === "composition-relationship" && r.source.id === capability.id);
        return incomingCompositions.size() > 0;
    });
}

function calculateCapabilitySize(capability, children) {
    const minWidth = 150;
    const minHeight = 60;
    const padding = 40;

    if (children.size() === 0) {
        return [Math.max(minWidth, capability.name.length * 10), minHeight];
    }

    let maxChildWidth = 0;
    let totalChildHeight = 0;

    children.each(child => {
        const [childWidth, childHeight] = calculateCapabilitySize(child, getCapabilityChildren(child));
        maxChildWidth = Math.max(maxChildWidth, childWidth);
        totalChildHeight += childHeight + 20; // 20px vertical spacing
    });

    const width = Math.max(minWidth, maxChildWidth + padding, capability.name.length * 10);
    const height = Math.max(minHeight, totalChildHeight + padding);

    return [width, height];
}

function layoutChildren(view, parentInView, children, startX, startY, maxWidth) {
    let y = startY;

    children.each(child => {
        const grandchildren = getCapabilityChildren(child);
        const [width, height] = calculateCapabilitySize(child, grandchildren);

        const childInView = view.add(child, startX, y, width, height);
        childInView.textPosition = 1; // Set text position to center
        childInView.showIcon = 2;

        if (grandchildren.size() === 0) {
            childInView.fillColor = "#F0F0F0"; // Light grey for leaf nodes
        } else {
            childInView.textPosition = 0; // Set text position to top
            layoutChildren(view, childInView, grandchildren, startX + 20, y + 40, width - 40);
        }

        y += height + 20; // 20px vertical spacing
    });
}