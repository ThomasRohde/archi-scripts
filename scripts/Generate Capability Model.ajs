/**
 * @name Generate Capability Model
 * @description This script generates an ArchiMate capability model using the Anthropic API, iteratively refining the model.
 */

console.clear();
console.show();

const { LLMClient, LLMMessage, LLMGenerateOptions, ROLES } = require('./lib/llm');
const layoutDagre = require('./lib/layoutDagre');
const modelManipulation = require('./lib/modelManipulation');

// Initialize logger
const jarchiLogger = require('./lib/jarchiLogger');
const log = jarchiLogger.createLogger('GenerateCapabilityModel', __DIR__);

// Initialize LLM client
// const llmClient = new LLMClient('anthropic');
const llmClient = new LLMClient('ollama');

// Constants
const ITERATIONS = 3;
// const MODEL = 'claude-3-haiku-20240307';
const MODEL = 'llama3.1';

// Function to get user input
function getUserInput(prompt) {
    return window.prompt(prompt);
}

// Function to generate capability model using LLM
async function generateCapabilityModel(userDescription, previousModel = null, iteration = 1) {
    let prompt = `You are an AI assistant tasked with creating an ArchiMate capability model based on a user's description. Your goal is to analyze the description and generate a JSON object that represents the capability model using only ArchiMate Strategy Capability elements.

Here is the user's description of the organization:
<user_description>
${userDescription}
</user_description>

This is iteration ${iteration} of ${ITERATIONS}. `;

    if (iteration === 1) {
        prompt += "Create an initial high-level capability model.";
    } else {
        prompt += `Expand and refine the previous model. For each capability in the previous model, provide more detailed sub-capabilities.

Previous model:
<previous_model>
${JSON.stringify(previousModel, null, 2)}
</previous_model>`;
    }

    prompt += `

Create a JSON object to represent the ArchiMate capability model. The structure should be:

<json_structure>
{
    "nodes": [
        {
            "id": "<unique id>",
            "type": "capability",
            "name": "<name of capability>",
            "description": "<description of capability>",
            "children": [ ... child capabilities ...]
        },
        ... more capabilities ...
    ],
    "relationships": [
        {
            "source": "<id of source capability>",
            "target": "<id of target capability>",
            "type": "composition-relationship"
        },
        ... more relationships ...
    ]
}
</json_structure>

Guidelines:
1. Use only "capability" as the type for all nodes.
2. Create a hierarchical structure with high-level capabilities and sub-capabilities.
3. Use "composition-relationship" to represent the hierarchy.
4. Provide clear and concise names and descriptions for each capability.
5. Ensure each capability has a unique ID (e.g., "cap1", "cap2", etc.).
6. If refining a previous model, maintain the existing structure and add more detailed sub-capabilities.

After analyzing the description and creating the model, format your response as a valid JSON object representing the capability model. Enclose the entire JSON object within <capability_model> tags.`;

    const messages = [new LLMMessage(ROLES.USER, prompt)];

    const options = new LLMGenerateOptions({
        model: MODEL,
        maxTokens: 4000,
        temperature: 0.7
    });

    try {
        const response = await llmClient.generateChatCompletion(messages, options);
        const content = response.content;
        
        log.markdown(content.replace(/<capability_model>[\s\S]*?<\/capability_model>/, ''));

        const jsonMatch = content.match(/<capability_model>([\s\S]*?)<\/capability_model>/);
        if (jsonMatch) {
            const jsonObject = JSON.parse(jsonMatch[1]);
            log.code(jsonObject);
            return jsonObject;
        } else {
            throw new Error("JSON structure not found in the response");
        }
    } catch (error) {
        log.error('Error generating capability model', { error: error.toString() });
        throw error;
    }
}

// Main execution
(async function() {
    try {
        const userDescription = getUserInput("Describe the organization for which you want to create a capability model:");
        if (userDescription) {
            log.info('Generating capability model');
            let view = $(selection).filter("archimate-diagram-model").first();
            if (!view) {
                view = model.createArchimateView("Generated Capability Model");
            }

            let previousModel = null;

            for (let i = 1; i <= ITERATIONS; i++) {
                log.info(`Iteration ${i} of ${ITERATIONS}`);
                const modelJson = await generateCapabilityModel(userDescription, previousModel, i);
                
                if (i < ITERATIONS) {
                    // Use updateModel for all iterations except the last one
                    const updates = modelManipulation.updateModel(modelJson);
                    log.info(`Model updated (iteration ${i})`);
                    log.debug('Model updates', updates);
                } else {
                    // For the last iteration, update the view and apply layout
                    modelManipulation.updateView(view, modelJson);
                    layoutDagre(view);
                    log.info('Final model applied to view and layout updated');
                }
                
                // Update previousModel for the next iteration
                previousModel = modelManipulation.createModelJson();
            }

            log.info('Capability model generation complete');
        } else {
            log.warn('User cancelled or provided no description');
        }
    } catch (error) {
        log.error('Error in main execution', { error: error.toString() });
    }
})();