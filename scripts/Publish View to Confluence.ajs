/**
 * @module PublishViewToConfluence
 * @description Publishes the currently selected view to a Confluence page with enhanced structure, Markdown support, and expandable element sections
 * @version 3.1
 * @author Claude AI Assistant
 * @lastModifiedDate 2024-07-31
 */

console.clear();
console.show();

const apiClient = require("./lib/apiClient");
const marked = require('./node_modules/marked/marked.min');

function readConfluenceSettings() {
    const preferenceStore = workbench.getPreferenceStore();
    return {
        username: preferenceStore.getString('confluenceUsername'),
        apiToken: preferenceStore.getString('confluencePassword'),
        spaceKey: preferenceStore.getString('confluenceDefaultSpaceKey'),
        baseUrl: preferenceStore.getString('confluenceBaseUrl'),
    };
}

const confluenceApi = apiClient.create({
    auth: {
        username: readConfluenceSettings().username,
        password: readConfluenceSettings().apiToken
    },
    baseURL: readConfluenceSettings().baseUrl,
    headers: {
        'X-Atlassian-Token': 'no-check'
    }
});

async function getPageInfo(pageTitle) {
    try {
        const response = await confluenceApi.get('/wiki/rest/api/content', {
            params: {
                title: pageTitle,
                spaceKey: readConfluenceSettings().spaceKey,
                expand: 'version'
            }
        });

        if (response.data.results.length === 0) {
            return null;
        }

        const pageInfo = response.data.results[0];
        return {
            pageId: pageInfo.id,
            pageVersion: parseInt(pageInfo.version.number)
        };
    } catch (error) {
        console.error("Error getting page info:", error.message);
        throw error;
    }
}

async function updateConfluencePage(pageId, pageTitle, pageVersion, pageContents) {
    const isNewPage = !pageId;
    const method = isNewPage ? 'post' : 'put';
    const url = isNewPage 
        ? '/wiki/rest/api/content'
        : `/wiki/rest/api/content/${pageId}`;

    const requestData = {
        type: "page",
        title: pageTitle,
        space: { key: readConfluenceSettings().spaceKey },
        body: {
            storage: {
                value: pageContents,
                representation: "storage"
            }
        }
    };

    if (!isNewPage) {
        requestData.version = { number: pageVersion };
    }

    try {
        const response = await confluenceApi.request({
            method: method,
            url: url,
            data: requestData,
            headers: {
                'Content-Type': 'application/json'
            }
        });

        return {
            pageId: response.data.id,
            pageVersion: response.data.version ? response.data.version.number : 1
        };
    } catch (error) {
        console.error("Error updating Confluence page:", error.message);
        throw error;
    }
}   

async function attachFile(pageId, fileName, fileContent, fileType, comment) {
    try {
        const url = `/wiki/rest/api/content/${pageId}/child/attachment`;

        const response = await confluenceApi.uploadFile(url, {
            name: fileName,
            content: fileContent,
            type: fileType,
            comment: comment,
            contentType: fileType === "image" ? "image/png" : "text/plain"
        }, {
            method: 'POST',
            headers: {
                'X-Atlassian-Token': 'no-check'
            }
        });

        return {
            id: response.data.results[0].id,
            title: response.data.results[0].title,
            version: response.data.results[0].version.number
        };
    } catch (error) {
        console.error("Error attaching file:", error.message);
        throw error;
    }
}

function preprocessMarkdown(content) {
    // Replace single newlines with two spaces followed by a newline
    // This ensures that Markdown creates a line break
    return content.replace(/(?<!\n)\n(?!\n)/g, "  \n");
}

function processMarkdown(content) {
    const preprocessed = preprocessMarkdown(content);
    return marked.parse(preprocessed);
}

function generateElementContent(element) {
    let content = `<ac:structured-macro ac:name="expand">
        <ac:parameter ac:name="title">${element.name} (${element.type})</ac:parameter>
        <ac:rich-text-body>`;
    
    if (element.documentation) {
        content += processMarkdown(element.documentation);
    }
    
    const properties = element.prop();
    if (properties.length > 0) {
        content += '<h4>Properties</h4><table><tbody><tr><th>Property</th><th>Value</th></tr>';
        properties.forEach(prop => {
            content += `<tr><td>${prop}</td><td>${element.prop(prop)}</td></tr>`;
        });
        content += '</tbody></table>';
    }
    
    content += '</ac:rich-text-body></ac:structured-macro>';
    
    return content;
}

async function publishViewToConfluence() {
    try {
        const selectedView = $(selection).filter("archimate-diagram-model").first();
        if (!selectedView) {
            console.error("No view selected. Please select a view and run the script again.");
            return;
        }

        const confluenceSettings = readConfluenceSettings();
        if (!confluenceSettings.baseUrl || !confluenceSettings.spaceKey || !confluenceSettings.username || !confluenceSettings.apiToken) {
            console.error("Confluence settings are not properly configured. Please run the Confluence Settings script first.");
            return;
        }

        const pageTitle = selectedView.name;
        console.log(`Publishing view "${pageTitle}" to Confluence...`);

        const viewImage = $.model.renderViewAsBase64(selectedView, "PNG", { scale: 2, margin: 20 });

        let pageContents = `<h1>${pageTitle}</h1>`;

        // View Diagram
        const imageFileName = `${pageTitle.replace(/[^a-z0-9]/gi, "_").toLowerCase()}_diagram.png`;
        const imageContent = `<ac:image ac:align="center" ac:layout="center" ac:alt="${pageTitle} Diagram">
            <ri:attachment ri:filename="${imageFileName}" />
        </ac:image>`;
        pageContents += `<h2>View Diagram</h2>${imageContent}`;

        // View Documentation
        if (selectedView.documentation) {
            pageContents += `<h2>View Documentation</h2>${processMarkdown(selectedView.documentation)}`;
        }

        // Elements
        pageContents += `<h2>Elements</h2>`;
        $(selectedView).find("element").each((element) => {
            pageContents += generateElementContent(element);
        });

        let pageInfo = await getPageInfo(pageTitle);
        if (!pageInfo) {
            console.log("Creating new page...");
            pageInfo = { pageId: "", pageVersion: 0 };
        } else {
            console.log("Updating existing page...");
        }

        const result = await updateConfluencePage(
            pageInfo.pageId,
            pageTitle,
            pageInfo.pageVersion + 1,
            pageContents
        );

        console.log(`Page "${pageTitle}" ${pageInfo.pageId ? "updated" : "created"} successfully. Page ID: ${result.pageId}, Version: ${result.pageVersion}`);

        const attachmentComment = "View diagram";
        const attachmentResult = await attachFile(
            result.pageId,
            imageFileName,
            viewImage,
            "image",
            attachmentComment
        );

        console.log(`Image "${imageFileName}" attached successfully. Attachment ID: ${attachmentResult.id}, Version: ${attachmentResult.version}`);
    } catch (error) {
        console.error("An error occurred:", error.message);
    }
}

publishViewToConfluence();