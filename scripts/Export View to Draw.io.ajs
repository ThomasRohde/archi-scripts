/**
 * @name Export to draw.io (Hierarchical)
 * @version 4.2
 * @description Exports the selected ArchiMate view to a draw.io diagram file, handling nested elements using groups and correct coordinate systems
 */

console.clear();
console.show();

// Import required Java classes
const Files = Java.type("java.nio.file.Files");
const Paths = Java.type("java.nio.file.Paths");
const FileDialog = Java.type("org.eclipse.swt.widgets.FileDialog");
const SWT = Java.type("org.eclipse.swt.SWT");
const FileWriter = Java.type("java.io.FileWriter");

// XML processing
const DocumentBuilderFactory = Java.type("javax.xml.parsers.DocumentBuilderFactory");
const TransformerFactory = Java.type("javax.xml.transform.TransformerFactory");
const DOMSource = Java.type("javax.xml.transform.dom.DOMSource");
const StreamResult = Java.type("javax.xml.transform.stream.StreamResult");

// Import mapping functions
const { mapArchiMateTypeToDrawIo, mapArchiMateRelationshipToDrawIo } = require("./lib/archiMateDrawIoMappings");

function exportToDiagram() {
    const selectedView = $(selection).filter("archimate-diagram-model").first();
    if (!selectedView) {
        console.error("No view selected. Please select an ArchiMate view and run the script again.");
        return;
    }

    const diagram = createDrawIoDiagram(selectedView);
    saveDrawIoDiagram(diagram, selectedView.name);
}

function createDrawIoDiagram(view) {
    const dbFactory = DocumentBuilderFactory.newInstance();
    const dBuilder = dbFactory.newDocumentBuilder();
    const doc = dBuilder.newDocument();

    const mxfile = doc.createElement("mxfile");
    doc.appendChild(mxfile);

    const diagram = doc.createElement("diagram");
    diagram.setAttribute("name", view.name);
    diagram.setAttribute("id", view.id);
    mxfile.appendChild(diagram);

    const mxGraphModel = doc.createElement("mxGraphModel");
    diagram.appendChild(mxGraphModel);

    const root = doc.createElement("root");
    mxGraphModel.appendChild(root);

    const layer = doc.createElement("mxCell");
    layer.setAttribute("id", "0");
    root.appendChild(layer);

    const parent = doc.createElement("mxCell");
    parent.setAttribute("id", "1");
    parent.setAttribute("parent", "0");
    root.appendChild(parent);

    let idCounter = 2;
    const elementMap = new Map();

    function traverseElements(element, parentId) {
        const cell = createDrawIoElement(doc, element, idCounter++, parentId);
        root.appendChild(cell);
        elementMap.set(element.id, cell);

        $(element)
            .children("element")
            .each((childElement) => {
                traverseElements(childElement, cell.getAttribute("id"));
            });
    }

    // Traverse the view hierarchy
    $(view)
        .children().not("relationship").not("diagram-model-connection")
        .each((element) => {
            traverseElements(element, "1");
        });

    // Create connections
    $(view)
        .children("relationship").add($(view).children("diagram-model-connection"))
        .each((relationship) => {
            const drawIoConnection = createDrawIoConnection(doc, relationship, elementMap, idCounter++);
            if (drawIoConnection) {
                root.appendChild(drawIoConnection);
            }
        });

    return doc;
}

function createDrawIoElement(doc, element, id, parentId) {
    const cell = doc.createElement("mxCell");
    cell.setAttribute("id", id);
    cell.setAttribute("value", element.type === "diagram-model-note" ? element.text : element.name);
    cell.setAttribute("parent", parentId);
    cell.setAttribute("vertex", "1");

    const hasChildren = $(element).children("element").size() > 0;

    let style = mapArchiMateTypeToDrawIo(element.type) + ";whiteSpace=wrap;";

    if (hasChildren) {
        style += "container=1;collapsible=0;";
        if (!style.includes("swimlane")) {
            style += "labelPosition=center;verticalLabelPosition=top;align=center;verticalAlign=bottom;";
        }
    }

    style += `fillColor=${getFillColor(element)};`;

    cell.setAttribute("style", style);

    const geometry = doc.createElement("mxGeometry");
    geometry.setAttribute("x", element.bounds.x);
    geometry.setAttribute("y", element.bounds.y);
    geometry.setAttribute("width", element.bounds.width);
    geometry.setAttribute("height", element.bounds.height);
    geometry.setAttribute("as", "geometry");

    cell.appendChild(geometry);

    return cell;
}

function createDrawIoConnection(doc, connection, elementMap, id) {
    const cell = doc.createElement("mxCell");
    cell.setAttribute("id", id);
    cell.setAttribute("value", connection.name || "");
    cell.setAttribute("parent", "1");
    cell.setAttribute("edge", "1");

    const sourceElement = elementMap.get(connection.source.id);
    const targetElement = elementMap.get(connection.target.id);

    cell.setAttribute("source", sourceElement.getAttribute("id"));
    cell.setAttribute("target", targetElement.getAttribute("id"));

    const style = mapArchiMateRelationshipToDrawIo(connection.type) + "edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;";
    cell.setAttribute("style", style);

    const geometry = doc.createElement("mxGeometry");
    geometry.setAttribute("relative", "1");
    geometry.setAttribute("as", "geometry");

    // Add bend points
    const bendPoints = getBendPoints(connection);
    if (bendPoints.length > 0) {
        const array = doc.createElement("Array");
        array.setAttribute("as", "points");
        bendPoints.forEach(point => {
            const mxPoint = doc.createElement("mxPoint");
            mxPoint.setAttribute("x", point.x);
            mxPoint.setAttribute("y", point.y);
            array.appendChild(mxPoint);
        });
        geometry.appendChild(array);
    }

    cell.appendChild(geometry);

    return cell;
}

function getBendPoints(connection) {
    const bendPoints = [];
    const relativeBendpoints = connection.getRelativeBendpoints();
    if (relativeBendpoints && relativeBendpoints.length > 0) {
        const sourceXY = getObjXY(connection.source);
        relativeBendpoints.forEach(point => {
            const absoluteX = sourceXY.x + point.startX;
            const absoluteY = sourceXY.y + point.startY;
            bendPoints.push({ x: absoluteX, y: absoluteY });
        });
    }
    return bendPoints;
}

function getObjXY(obj) {
    let b = obj.bounds;
    let x = b.x + b.width / 2;
    let y = b.y + b.height / 2;
    $(obj).parents().forEach(p => {
        try {
            x += p.bounds.x;
            y += p.bounds.y;
        } catch (e) {
        }
    });

    return {
        x: x,
        y: y,
        width: b.width,
        height: b.height
    };
}

function getFillColor(element) {
    const existingFillColor = element.fillColor;
    if (existingFillColor) {
        return existingFillColor;
    }

    const colorMap = {
        strategy: "#F5DEAA",
        business: "#FFFFB5",
        application: "#99FFFF",
        technology: "#AFFFAF",
        physical: "#AFFFAF",
        motivation: "#CCCCFF",
        implementation: "#FFE0E0",
        other: "#FFFFFF"
    };

    const layerMap = {
        // Strategy
        "resource": "strategy",
        "capability": "strategy",
        "course-of-action": "strategy",
        "value-stream": "strategy",

        // Business
        "business-actor": "business",
        "business-role": "business",
        "business-collaboration": "business",
        "business-interface": "business",
        "business-process": "business",
        "business-function": "business",
        "business-interaction": "business",
        "business-event": "business",
        "business-service": "business",
        "business-object": "business",
        "contract": "business",
        "representation": "business",
        "product": "business",

        // Application
        "application-component": "application",
        "application-collaboration": "application",
        "application-interface": "application",
        "application-function": "application",
        "application-process": "application",
        "application-interaction": "application",
        "application-event": "application",
        "application-service": "application",
        "data-object": "application",

        // Technology
        "node": "technology",
        "device": "technology",
        "system-software": "technology",
        "technology-collaboration": "technology",
        "technology-interface": "technology",
        "path": "technology",
        "communication-network": "technology",
        "technology-function": "technology",
        "technology-process": "technology",
        "technology-interaction": "technology",
        "technology-event": "technology",
        "technology-service": "technology",
        "artifact": "technology",

        // Physical
        "equipment": "physical",
        "facility": "physical",
        "distribution-network": "physical",
        "material": "physical",

        // Motivation
        "stakeholder": "motivation",
        "driver": "motivation",
        "assessment": "motivation",
        "goal": "motivation",
        "outcome": "motivation",
        "principle": "motivation",
        "requirement": "motivation",
        "constraint": "motivation",
        "meaning": "motivation",
        "value": "motivation",

        // Implementation & Migration
        "work-package": "implementation",
        "deliverable": "implementation",
        "implementation-event": "implementation",
        "plateau": "implementation",
        "gap": "implementation",

        // Other
        "location": "other",
        "grouping": "other",
        "junction": "other"
    };

    let type;
    try {
        type = element.concept.type;
    } catch {
        type = element.type;
    }

    const layer = layerMap[type] || "other";
    return colorMap[layer];
}

function saveDrawIoDiagram(diagram, viewName) {
    const fileDialog = new FileDialog(shell, SWT.SAVE);
    fileDialog.setFilterExtensions(["*.drawio"]);
    fileDialog.setFileName(viewName.replace(/[^a-zA-Z0-9]/g, "_") + ".drawio");
    const filePath = fileDialog.open();

    if (filePath) {
        const transformerFactory = TransformerFactory.newInstance();
        const transformer = transformerFactory.newTransformer();
        const source = new DOMSource(diagram);
        const result = new StreamResult(Files.newOutputStream(Paths.get(filePath)));
        transformer.transform(source, result);
        console.log(`Diagram saved successfully: ${filePath}`);
    } else {
        console.log("Export cancelled by user.");
    }
}

// Execute the export function
exportToDiagram();