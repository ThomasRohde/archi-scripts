<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JArchi Logger</title>
    <link href="/output.css" rel="stylesheet">
    <script src="/luxon.min.js"></script>
    <script src="/json-formatter.umd.min.js"></script>
    <style>
        .log-row:nth-child(even) {
            background-color: #f9fafb;
        }
        .log-row:hover {
            background-color: #e5e7eb;
        }
        .log-row {
            border-bottom: 1px solid #e5e7eb;
        }
        .log-summary {
            cursor: pointer;
            padding: 0.1rem;
        }
        .log-details {
            padding: 0.1rem;
            background-color: #f8f8f8;
            border-top: 1px solid #e5e7eb;
        }
        /* JSON Formatter Styles */
        .json-formatter-row {
            font-family: monospace;
            margin-left: 1em;
        }
        .json-formatter-row, .json-formatter-row a, .json-formatter-row a:hover {
            color: #000;
            text-decoration: none;
        }
        .json-formatter-row .json-formatter-row {
            margin-left: 1em;
        }
        .json-formatter-row .json-formatter-children.json-formatter-empty {
            opacity: 0.5;
            margin-left: 1em;
        }
        .json-formatter-row .json-formatter-children.json-formatter-empty:after {
            display: none;
        }
        .json-formatter-row .json-formatter-children.json-formatter-empty.json-formatter-object:after {
            content: "No properties";
        }
        .json-formatter-row .json-formatter-children.json-formatter-empty.json-formatter-array:after {
            content: "[]";
        }
        .json-formatter-row .json-formatter-string,
        .json-formatter-row .json-formatter-stringifiable {
            color: #a31515;
            white-space: pre;
            word-wrap: break-word;
        }
        .json-formatter-row .json-formatter-number {
            color: #098658;
        }
        .json-formatter-row .json-formatter-boolean {
            color: #0000ff;
        }
        .json-formatter-row .json-formatter-null {
            color: #0000ff;
        }
        .json-formatter-row .json-formatter-undefined {
            color: #767676;
        }
        .json-formatter-row .json-formatter-function {
            color: #767676;
        }
        .json-formatter-row .json-formatter-date {
            color: #0000ff;
        }
        .json-formatter-row .json-formatter-url {
            color: #0000ff;
        }
        .json-formatter-row .json-formatter-bracket {
            color: #000000;
        }
        .json-formatter-row .json-formatter-key {
            color: #0451a5;
            padding-right: 0.2em;
        }
        .json-formatter-row .json-formatter-toggler-link {
            cursor: pointer;
        }
        .json-formatter-row .json-formatter-toggler {
            line-height: 1.2em;
            font-size: 0.7em;
            vertical-align: middle;
            opacity: 0.6;
            cursor: pointer;
            padding-right: 0.2em;
        }
        .json-formatter-row .json-formatter-toggler:after {
            display: inline-block;
            transition: transform 100ms ease-in;
            content: "â–º";
        }
        .json-formatter-row > a > .json-formatter-preview-text {
            opacity: 0.3;
            transition: opacity 0.15s ease-in;
            font-style: italic;
        }
        .json-formatter-row:hover > a > .json-formatter-preview-text {
            opacity: 0.6;
        }
        .json-formatter-row.json-formatter-open > .json-formatter-toggler-link .json-formatter-toggler:after {
            transform: rotate(90deg);
        }
        .json-formatter-row.json-formatter-open > .json-formatter-children:after {
            display: inline-block;
        }
        .json-formatter-row.json-formatter-open > a > .json-formatter-preview-text {
            display: none;
        }
        .json-formatter-row.json-formatter-open.json-formatter-empty:after {
            display: block;
        }
    </style>
</head>

<body class="bg-gray-100 font-sans">
    <div class="container mx-auto p-4">
        <h1 class="text-2xl font-bold mb-4">JArchi Logger</h1>
        <button id="clearLogsBtn" class="mb-4 bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">
            Clear Logs
        </button>
        <div id="logContainer" class="bg-white shadow-md rounded-lg overflow-hidden">
            <table class="w-full text-sm text-left">
                <thead class="text-xs text-gray-700 uppercase bg-gray-200">
                    <tr>
                        <th class="px-4 py-2">Timestamp</th>
                        <th class="px-4 py-2">Level</th>
                        <th class="px-4 py-2">Script</th>
                        <th class="px-4 py-2">Message</th>
                    </tr>
                    <tr>
                        <th class="px-4 py-2"><input type="text" class="w-full px-2 py-1 text-sm rounded border"
                                placeholder="Filter Timestamp" id="filterTimestamp"></th>
                        <th class="px-4 py-2"><input type="text" class="w-full px-2 py-1 text-sm rounded border"
                                placeholder="Filter Level" id="filterLevel"></th>
                        <th class="px-4 py-2"><input type="text" class="w-full px-2 py-1 text-sm rounded border"
                                placeholder="Filter Script" id="filterScript"></th>
                        <th class="px-4 py-2"><input type="text" class="w-full px-2 py-1 text-sm rounded border"
                                placeholder="Filter Message" id="filterMessage"></th>
                    </tr>
                </thead>
                <tbody id="logTableBody">
                </tbody>
            </table>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const logTableBody = document.getElementById('logTableBody');
        const filterInputs = document.querySelectorAll('input[id^="filter"]');
        const { DateTime } = luxon;

        // Configuration
        const LOG_RETENTION_TIME = 60 * 60 * 1000; // 1 hour in milliseconds
        const CLEANUP_INTERVAL = 5 * 60 * 1000; // Run cleanup every 5 minutes

        const LOG_LEVEL_COLORS = {
            DEBUG: 'bg-gray-500',
            INFO: 'bg-green-500',
            WARN: 'bg-yellow-500',
            ERROR: 'bg-red-500'
        };

        function formatTimestamp(isoString) {
            if (!isoString) return 'Invalid Date';
            const date = DateTime.fromISO(isoString, { zone: 'UTC' });
            return date.isValid ? date.toLocal().toFormat('yyyy-MM-dd HH:mm:ss') : 'Invalid Date';
        }

        function createLogRow(log) {
            if (!log || typeof log !== 'object') {
                console.error('Invalid log entry:', log);
                return document.createElement('tr');
            }

            const row = document.createElement('tr');
            row.className = 'log-row';
            const formattedTimestamp = log.timestamp ? formatTimestamp(log.timestamp) : 'N/A';
            
            row.innerHTML = `
                <td class="px-4 py-2 text-gray-500" data-timestamp="${log.timestamp || ''}">${formattedTimestamp}</td>
                <td class="px-4 py-2">
                    <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full text-white ${LOG_LEVEL_COLORS[log.level] || 'bg-gray-500'}">
                        ${log.level || 'UNKNOWN'}
                    </span>
                </td>
                <td class="px-4 py-2">${log.script || 'N/A'}</td>
                <td>
                    <div class="log-summary" onclick="toggleDetails(this)">${log.message || 'No message'}</div>
                    <div class="log-details hidden"></div>
                </td>
            `;

            if (log.additionalData) {
                const formatter = new JSONFormatter(log.additionalData, 1, {
                    hoverPreviewEnabled: true,
                    hoverPreviewArrayCount: 100,
                    hoverPreviewFieldCount: 5,
                    theme: 'light',
                    animateOpen: true,
                    animateClose: true
                });
                
                row.querySelector('.log-details').appendChild(formatter.render());
            }

            return row;
        }

        function toggleDetails(element) {
            const details = element.nextElementSibling;
            details.classList.toggle('hidden');
        }

        filterInputs.forEach(input => {
            input.addEventListener('input', applyFilters);
        });

        function applyFilters() {
            const filters = {
                timestamp: document.getElementById('filterTimestamp').value.toLowerCase(),
                level: document.getElementById('filterLevel').value.toLowerCase(),
                script: document.getElementById('filterScript').value.toLowerCase(),
                message: document.getElementById('filterMessage').value.toLowerCase()
            };

            const rows = logTableBody.querySelectorAll('tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const shouldShow = (
                    cells[0].textContent.toLowerCase().includes(filters.timestamp) &&
                    cells[1].textContent.toLowerCase().includes(filters.level) &&
                    cells[2].textContent.toLowerCase().includes(filters.script) &&
                    cells[3].textContent.toLowerCase().includes(filters.message)
                );
                row.style.display = shouldShow ? '' : 'none';
            });
        }

        function cleanupOldLogs() {
            const currentTime = new Date().getTime();
            const rows = logTableBody.querySelectorAll('tr');
            rows.forEach(row => {
                const timestampCell = row.querySelector('td[data-timestamp]');
                if (timestampCell) {
                    const logTime = new Date(timestampCell.dataset.timestamp).getTime();
                    if (currentTime - logTime > LOG_RETENTION_TIME) {
                        row.remove();
                    }
                }
            });
        }

        // Run cleanup periodically
        setInterval(cleanupOldLogs, CLEANUP_INTERVAL);

        socket.on('connect', () => {
            console.log('Connected to server');
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
        });

        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
        });

        document.getElementById('clearLogsBtn').addEventListener('click', function () {
            if (confirm('Are you sure you want to clear all logs?')) {
                fetch('/clear-logs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                })
                    .then(response => {
                        if (response.ok) {
                            console.log('Logs cleared successfully');
                            clearLogDisplay();
                            location.reload();
                        } else {
                            console.error('Failed to clear logs');
                        }
                    })
                    .catch(error => console.error('Error:', error));
            }
        });

        function clearLogDisplay() {
            logTableBody.innerHTML = '';
            filterInputs.forEach(input => {
                input.value = '';
            });
            applyFilters();
            console.log('Log display cleared');
        }

        socket.on('logsCleared', function () {
            clearLogDisplay();
            console.log('Received logsCleared event');
        });

        socket.on('initialLogs', function (initialLogs) {
            logTableBody.innerHTML = '';
            initialLogs.forEach(log => {
                if (log && typeof log === 'object') {
                    logTableBody.appendChild(createLogRow(log));
                }
            });
            applyFilters();
        });

        socket.on('newLog', (logEntry) => {
            if (logEntry && typeof logEntry === 'object') {
                const newRow = createLogRow(logEntry);
                logTableBody.insertBefore(newRow, logTableBody.firstChild);
                applyFilters();
            } else {
                console.error('Received invalid log entry:', logEntry);
            }
        });
    </script>
</body>

</html>